# TRD-007: 开发/测试/生产三环境技术实现

## 1. 背景
基于 [BRN-007](../../origin/BRN-007.dev_test_prod_design.md) 决策，实现 dev/test/prod 三环境隔离机制，支持热更新、Docker 快速拉起、环境变量控制。

## 2. 架构设计

### 2.1 环境变量体系
```
.env.dev    → PEG_ENV=development, DB_TABLE_PREFIX=dev_, NEO4J_BOLT_PORT=7687
.env.test   → PEG_ENV=test, DB_TABLE_PREFIX=test_, NEO4J_BOLT_PORT=7688
.env.prod   → PEG_ENV=production, DB_TABLE_PREFIX=prod_, NEO4J_BOLT_PORT=7689
```

**关键变量**（已有 `connection.py` 支持）：
- `PEG_ENV`: 环境标识，控制 `DEBUG` 开关
- `DB_TABLE_PREFIX`: Neo4j Label 前缀（`dev_Company` / `prod_Company`）
- `NEO4J_URI`, `NEO4J_USER`, `NEO4J_PASSWORD`: 数据库连接
- `NEO4J_CONTAINER`, `NEO4J_DATA_DIR`: Docker 容器配置

### 2.2 Docker Compose 三环境配置
```yaml
# docker-compose.yml
services:
  neo4j-dev:
    image: neo4j:5
    ports: ["7474:7474", "7687:7687"]
    volumes: ["./x-data/neo4j/dev:/data"]
    environment:
      NEO4J_AUTH: neo4j/pegscanner

  neo4j-test:
    image: neo4j:5
    ports: ["7475:7474", "7688:7687"]
    volumes: ["./x-data/neo4j/test:/data"]
    environment:
      NEO4J_AUTH: neo4j/test123

  neo4j-prod:
    image: neo4j:5
    ports: ["7476:7474", "7689:7687"]
    volumes: ["./x-data/neo4j/prod:/data"]
    environment:
      NEO4J_AUTH: neo4j/${NEO4J_PASSWORD}

  # Celery + Redis（未来）
  redis:
    image: redis:7-alpine
    ports: ["6379:6379"]
  
  celery-worker:
    build: ./apps/backend
    command: celery -A tasks worker
    environment:
      PEG_ENV: ${PEG_ENV:-development}
      CELERY_BROKER_URL: redis://redis:6379/0
    depends_on: [redis]
    profiles: [celery]  # 可选启动

  backend:  # 生产部署
    build: .
    command: uvicorn apps.backend.main:app --host 0.0.0.0 --workers 4
    environment:
      PEG_ENV: production
      NEO4J_URI: bolt://neo4j-prod:7687
      DB_TABLE_PREFIX: prod_
    ports: ["8000:8000"]
```

### 2.3 数据隔离策略

#### 方案 A：Label 前缀（已实现）
```python
# libs/neo4j_repo/connection.py（已有）
@dataclass(frozen=True)
class Settings:
    db_table_prefix: str  # 从环境变量 DB_TABLE_PREFIX 读取

    def prefixed_label(self, base: str) -> str:
        return f"{self.db_table_prefix}{base}" if self.db_table_prefix else base

# 使用示例
settings = get_settings()
query = f"MATCH (c:{settings.prefixed_label('Company')} {{ticker: $ticker}})"
# dev: MATCH (c:dev_Company {ticker: 'AAPL'})
# prod: MATCH (c:prod_Company {ticker: 'AAPL'})
```

**风险缓解**：
- Repository 层封装，禁止直接写裸 Cypher
- 单元测试校验所有查询使用 `prefixed_label()`

#### 方案 B：独立数据库（CI 可选）
- 设置 `NEO4J_DATABASE=neo4j_test`
- 需 Neo4j Enterprise（社区版仅单库）

### 2.4 热更新机制（已实现）

#### Backend
```bash
# nx.json 或 project.json
uvicorn apps.backend.main:app --reload --host 0.0.0.0 --port 8000
```
- 监听 `apps/backend/**/*.py` 变化
- <2s 自动重载，连接保持

#### Frontend
```typescript
// apps/mobile/vite.config.ts（已有）
export default defineConfig({
  server: {
    hmr: true,  // 热模块替换
    watch: { usePolling: false }
  }
});
```

#### GraphQL Schema Codegen
```bash
# 添加 watch 模式（可选）
npm run codegen:watch
# 监听 libs/schema/*.graphql 变化，自动生成类型
```

## 3. 启动脚本增强

### 3.1 增强 tools/dev.sh
```bash
#!/usr/bin/env bash
set -e
ROOT=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
cd "$ROOT"

load_env() {
    if [ -f ".env.$1" ]; then
        export $(cat ".env.$1" | grep -v '^#' | xargs)
        echo "[dev.sh] loaded .env.$1"
    fi
}

case "$1" in
    dev)
        load_env dev
        docker-compose up -d neo4j-dev
        npm run dev
        ;;
    test)
        load_env test
        docker-compose up -d neo4j-test
        npm test
        ;;
    prod)
        load_env prod
        docker-compose up -d neo4j-prod backend frontend
        ;;
    stop)
        docker-compose down
        pkill -f "uvicorn" || true
        pkill -f "vite" || true
        ;;
    *)
        echo "Usage: $0 {dev|test|prod|stop}"
        exit 1
        ;;
esac
```

### 3.2 环境变量模板
创建 `.env.example` 模板（已创建但被 gitignore），开发者复制为 `.env.dev` 等：
```bash
# 初始化环境
cp .env.example .env.dev
# 修改密码等敏感信息
```

## 4. CI/CD 集成

### 4.1 GitHub Actions 更新
```yaml
# .github/workflows/ci.yml
jobs:
  test:
    steps:
      - name: Setup test env
        run: |
          cp .env.example .env.test
          sed -i 's/NEO4J_BOLT_PORT=7687/NEO4J_BOLT_PORT=7688/' .env.test
          export $(cat .env.test | xargs)
      
      - name: Start Neo4j test container
        run: docker-compose up -d neo4j-test
      
      - name: Run tests
        env:
          PEG_ENV: test
        run: |
          npm run bootstrap-dev
          npm test
      
      - name: Cleanup
        run: docker-compose down -v
```

### 4.2 生产部署
```bash
# 服务器上
export NEO4J_PASSWORD=$(vault read secret/pegscanner/neo4j)
docker-compose --profile prod up -d
```

## 5. 实施计划（6h）

| Phase | 任务 | 时间 | 产物 |
|-------|------|------|------|
| 1 | 创建环境变量模板 | 1h | `.env.example`, `.gitignore` 更新 |
| 2 | 更新 docker-compose.yml | 1.5h | 三组 Neo4j 服务 + Celery 占位 |
| 3 | 增强 tools/dev.sh | 1h | 支持 dev/test/prod 参数 |
| 4 | 验证热更新 | 0.5h | 修改代码确认 <2s 生效 |
| 5 | CI 集成测试 | 1h | 更新 `.github/workflows/ci.yml` |
| 6 | 文档 + 清理 | 1h | 更新 README, 删除临时文件 |

### 5.1 文件清单
**新建**（3 个）：
- `.env.example`（模板，已创建）
- `docs/specs/tech/TRD-007.md`（本文档）
- `docs/project/BRN-007/`（迭代目录）

**修改**（4 个）：
- `docker-compose.yml`（增加三环境 Neo4j）
- `tools/dev.sh`（加载 .env 文件）
- `.github/workflows/ci.yml`（测试环境）
- `README.md`（环境说明）

**待确认**：
- `libs/neo4j_repo/connection.py`（检查是否需要微调）
- `package.json`（添加 `codegen:watch` 脚本）

## 6. 测试策略

### 6.1 环境隔离测试
```python
# tests/test_env_isolation.py
def test_dev_prefix():
    os.environ["PEG_ENV"] = "development"
    reset_settings_cache()
    settings = get_settings()
    assert settings.db_table_prefix == "dev_"
    assert settings.prefixed_label("Company") == "dev_Company"

def test_prod_prefix():
    os.environ["PEG_ENV"] = "production"
    os.environ["DB_TABLE_PREFIX"] = "prod_"
    reset_settings_cache()
    settings = get_settings()
    assert settings.prefixed_label("Company") == "prod_Company"
```

### 6.2 数据隔离验证
```cypher
// Neo4j 中检查
MATCH (n) RETURN DISTINCT labels(n);
// 应看到 dev_Company, test_Company, prod_Company 互不干扰
```

### 6.3 热更新验证
```bash
# 终端 1
npm run dev

# 终端 2（修改代码）
echo "# test hot reload" >> apps/backend/resolvers/ping.py

# 观察终端 1 输出
# [uvicorn] Detected file change, reloading... (<2s)
```

## 7. 风险与缓解

| 风险 | 影响 | 缓解 |
|------|------|------|
| Label 前缀遗漏导致数据污染 | High | 单元测试 + Repository 层封装 |
| 多环境端口冲突 | Medium | 脚本启动前检查端口（`lsof -ti TCP:7687`） |
| .env 文件泄露密码 | High | `.gitignore` 忽略 `.env.*`，生产用 secrets |
| Celery 增加启动复杂度 | Low | 使用 `--profile celery` 可选启动 |
| 三套 Neo4j 占用磁盘/内存 | Low | 仅开发机同时跑，生产/CI 按需启动 |

## 8. 参考文档
- [BRN-007: 三环境决策](../../origin/BRN-007.dev_test_prod_design.md)
- [BRN-002: GraphQL 协议](../../origin/BRN-002.graphql_protocol_decision.md)
- [12-Factor App: Config](https://12factor.net/config)
- [Docker Compose Profiles](https://docs.docker.com/compose/profiles/)
- [Uvicorn Auto-reload](https://www.uvicorn.org/#command-line-options)

## 9. 附录：快速参考

### 常用命令
```bash
# 开发
npm run dev                     # 自动加载 .env.dev
tools/dev.sh dev                # 手动启动

# 测试
PEG_ENV=test npm test
docker-compose up -d neo4j-test

# 生产
docker-compose --profile prod up -d
npm start

# 调试
docker-compose ps               # 查看容器状态
docker logs pegscanner_neo4j_dev  # 查看 Neo4j 日志
curl http://localhost:7474      # 检查 dev Neo4j
```

### 环境切换
```bash
# 方式 1：修改 .env 文件
vim .env.dev

# 方式 2：临时切换
PEG_ENV=test npm run dev

# 方式 3：脚本切换
tools/dev.sh dev   # 自动加载 .env.dev
tools/dev.sh test  # 自动加载 .env.test
```

### 数据迁移
```cypher
// 从 dev 复制数据到 prod（危险！）
MATCH (d:dev_Company)
CREATE (p:prod_Company)
SET p = properties(d);

// 清空测试数据
MATCH (n:test_Company) DETACH DELETE n;
```

