# BRN-002: 协议与通信依赖（对应 TRD-002）

1. 业务需要「强协议 + 快迭代」，GraphQL 提供强 schema（SDL）、类型检查和前后端统一数据视图，优于裸 REST+JSON 口头约定。
2. JSON 本身是弱 schema，但这里仅作为传输格式；真正的约束由 GraphQL schema 保证，不会影响协议的强一致性。
3. GraphQL 更像 REST 的替代品，而非 Protobuf/Thrift 的平替；后者主要解决序列化与跨语言 RPC，本项目当前阶段并不需要。
4. 现阶段不引入 gRPC/Thrift，可降低复杂度，聚焦「HTTP/JSON + GraphQL」这一条链路，便于前后端协作与调试。
5. 采用 SDL + 代码生成模式：`.graphql` 作为唯一源（SSOT），前端生成 TS 类型/Hooks，后端实现 Resolver，避免多套协议漂移。
6. Python 后端选用 Flask 作为 Web 容器，原因是 Django 与 neomodel 集成体验不佳，而 Flask 对 ORM/驱动选择更中立、轻量。
7. 图数据库选 Neo4j，使用 neomodel 作为 OGM，以类模型描述节点与关系，可显著加速早期建模与 CRUD 迭代。
8. neomodel 仅作为「加速器」，通过 repository/service 层隔离，复杂查询直接写 Cypher，避免被 OGM API 绑死。
9. 性能与高级优化（批量操作、查询调优等）留待后期，通过替换 repository 实现即可演进为官方 driver + 手写 Cypher。
10. 综合考虑开发效率、协议清晰度与未来可演进性，最终技术决策为：**Flask + GraphQL (Ariadne/Strawberry) + HTTP/JSON + Neo4j + neomodel + repo 分层**。
